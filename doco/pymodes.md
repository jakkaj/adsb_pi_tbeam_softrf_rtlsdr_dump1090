Got it. I’ll gather detailed documentation on the `pymodes` Python library used for reading 1090 MHz ADS-B signals, including installation, usage examples, and a full API reference. I’ll structure it so an LLM coding agent can effectively use it.

I’ll update you as soon as it’s ready.

# pyModeS: Python ADS-B/Mode-S Decoder Documentation

## Overview

**pyModeS** is a Python library for decoding Mode S radar messages, including ADS-B (Automatic Dependent Surveillance–Broadcast) signals on 1090 MHz ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=The%20Python%20ADS)). It can be used to parse raw Mode S hex messages and extract information such as aircraft identification, position, altitude, velocity, and more. pyModeS supports decoding of multiple Downlink Format (DF) message types, for both short (56-bit) and long (112-bit) Mode S messages. In particular, it can decode: 

- **Surveillance replies** DF4/DF20 (Altitude code) and DF5/DF21 (Identity/Squawk code) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pyModeS%20supports%20the%20decoding%20of,following%20types%20of%20messages)).  
- **ADS-B messages** DF17/DF18 extended squitters, including:
  - Type Code 1–4 (BDS 0,8): Aircraft identification (callsign) and category ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,BDS%200%2C9%3A%20Airborne%20velocity)).
  - Type Code 5–8 (BDS 0,6): Surface position messages ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,to%20be%20implemented)).
  - Type Code 9–18 (BDS 0,5): Airborne position messages ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,B%20messages)).
  - Type Code 19 (BDS 0,9): Airborne velocity messages ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=%2A%20TC%3D5,Common%20usage%20GICB%20capability%20report)).
  - (Type Codes 28–31 for status/operational messages are planned but not yet implemented ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=%2A%20TC%3D9,BDS%202%2C0%3A%20Aircraft%20identification)).)  
- **Comm-B messages** (DF20/DF21), which contain Mode S **BDS registers** with additional information. pyModeS can decode many Comm-B message contents, including data link capability reports (BDS 1,0), transponder capability reports (BDS 1,7), aircraft identification (BDS 2,0), ACAS resolution advisories (BDS 3,0), selected altitude and meteorological reports (BDS 4,0, 4,4, 4,5), track and turn report (BDS 5,0), heading and speed report (BDS 6,0), etc ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,experimental)) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,6%2C0%3A%20Heading%20and%20speed%20report)).

This library can be used as a standalone tool or integrated into Python applications to **view and save live air traffic data** ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=PyModeS%20is%20a%20Python%20library,and%20save%20live%20traffic%20data)). It was created by Junzi Sun (TU Delft) and is open-source with contributions from many users ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=This%20is%20a%20project%20created,many%20contributors%20from%20different%20institutions)). If you use pyModeS in academic work, you are encouraged to cite the corresponding IEEE paper ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=If%20you%20find%20this%20project,considering%20cite%20this%20tool%20as)).

## Installation

pyModeS is available via pip and conda. Installation requires Python 3 and will automatically install core dependencies (NumPy and pyzmq) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Dependencies%20,automatically%20during%20previous%20installations%20processes)):

- **Stable release via pip:** Use `pip install pyModeS` to get the latest stable version from PyPI ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Installation%20examples%3A)). For example:  
  ```bash
  pip install pyModeS
  ```  
- **Conda (with compiled C extension):** Use `conda install -c conda-forge pymodes` to install from conda-forge ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,pyModeS)). This provides a pre-compiled version (including a C extension for speed) on supported platforms. For example:  
  ```bash
  conda install -c conda-forge pymodes
  ```  
- **Development version:** To install the latest development code, you can install directly from GitHub:  
  ```bash
  pip install git+https://github.com/junzis/pyModeS
  ```  
  Or clone the repository and install with Poetry:  
  ```bash
  git clone https://github.com/junzis/pyModeS  
  cd pyModeS  
  poetry install -E rtlsdr  
  ```  
  The development install with the `rtlsdr` extra will also set up SDR support (see below) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=conda%20install%20)) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,E%20rtlsdr)).

**Dependencies:** The required packages `numpy` (for numeric computations) and `pyzmq` (for networking support) are installed automatically with pyModeS ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Dependencies%20,automatically%20during%20previous%20installations%20processes)). If you plan to read directly from an RTL-SDR USB dongle, you will also need to install the `pyrtlsdr` package manually ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=installations%20processes)): 

```bash
pip install pyrtlsdr
``` 

*(The conda-forge installation of pyModeS may include SDR support by default, but with pip you should install `pyrtlsdr` yourself if needed.)* 

**Advanced Installation (C Module):** pyModeS includes an optional C/Cython extension to improve performance. The conda-forge package already uses this compiled module ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,pyModeS)). If you install via pip, pyModeS will work in pure Python mode by default, but you can compile the extension for speed. To build from source, run the provided make commands: 

```bash
git clone https://github.com/junzis/pyModeS  
cd pyModeS  
make ext  # build the C extension  
make install  # install the package  
``` 

This will compile and install pyModeS with the optimized native extension ([Welcome to pyModeS documentation! — pyModeS  documentation](https://mode-s.org/pymodes/api/#:~:text=Advanced%20installation%20)). The C extension significantly speeds up decoding when processing high volumes of messages.

## Usage Examples

pyModeS can be used both as a **command-line tool** for live data and as a **Python library** for decoding messages in your own programs. Below are several common usage scenarios.

### Live ADS-B Data via `modeslive`

When pyModeS is installed, it provides a command-line utility **`modeslive`** that connects to a data source (an SDR or network feed) and prints decoded aircraft data in real time. Running `modeslive` launches an interactive console display of nearby aircraft.

Basic usage of `modeslive`:

```bash
$ modeslive [-h] --source SOURCE [--connect SERVER PORT DATATYPE] [--latlon LAT LON] [--show-uncertainty] [--dumpto FOLDER]
``` 

Key arguments: 

- **--source**: Data source, either `"rtlsdr"` for a directly connected RTL-SDR dongle or `"net"` for network data ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,Display%20uncertainty%20values%2C%20default%20off)). 
- **--connect**: (For network source) TCP server host, port, and data format. Supported data types include `'raw'`, `'beast'`, and `'skysense'` (for AVR raw hex, Beast binary, or Skysense formats) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,Display%20uncertainty%20values%2C%20default%20off)). For example, `--connect localhost 30002 raw` would connect to a local AVR raw feed, and `--connect 127.0.0.1 30005 beast` connects to a Beast-format feed ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=If%20you%20want%20to%20connect,source%20switch%2C%20for%20example)).
- **--latlon**: Receiver latitude/longitude (if known). This is optional but can improve position decoding for certain messages (surface position decoding uses receiver location) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,dump%20decoded%20output%2C%20default%20none)).
- **--show-uncertainty**: If set, the output will include position/velocity uncertainty metrics when available (off by default).
- **--dumpto**: If specified, decodes will be written to files in the given folder (e.g., for logging data) instead of only showing on screen ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,Display%20uncertainty%20values%2C%20default%20off)).

For a quick start: 

- **Using an RTL-SDR USB receiver:** Plug in your dongle and run `modeslive --source rtlsdr`. This requires `pyrtlsdr` to be installed and will tune the SDR to 1090 MHz, demodulate Mode S signals, and display decoded aircraft messages ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=If%20you%20have%20an%20RTL,package%29%2C%20with%20command)) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,with%20command)). For example:  
  ```bash
  modeslive --source rtlsdr
  ``` 

- **Using a network data feed:** If you have a local feed (for instance, from `dump1090` or another ADS-B aggregator) that outputs raw Mode S messages over TCP, use `--source net`. You must provide the server address, port, and data format. For example:  
  ```bash
  modeslive --source net --connect 127.0.0.1 30005 beast
  ```  
  would connect to `127.0.0.1:30005` and decode messages in *Beast* binary format ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=If%20you%20want%20to%20connect,source%20switch%2C%20for%20example)). Likewise, using `30002 raw` would read ASCII hex messages on port 30002 ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=If%20you%20want%20to%20connect,source%20switch%2C%20for%20example)).

 ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS)) *Example output of the `modeslive` tool, showing a table of aircraft being tracked. Each row corresponds to an aircraft (identified by its ICAO address and callsign) along with decoded position (latitude, longitude, altitude) and velocity (ground speed, heading, vertical rate) information.* ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Example%20screenshot%3A))

*Tip:* You can press Ctrl+C to exit `modeslive`, or press Enter to lock onto a specific aircraft in the list. Using `--dumpto` will save decoded messages to text files for later analysis.

### Using the pyModeS Library in Python

You can also import pyModeS in your own Python scripts to decode Mode S messages. Begin by importing the library:

```python
import pyModeS as pms
```

The primary interface is through functions in the `pms` module (which provides top-level access to various decoders). For example, suppose you have a Mode S/ADS-B message in hex string form (28 hexadecimal characters). You can decode its contents as follows:

```python
msg = "8D4840D6202CC371C32CE0576098"  # example ADS-B message (28 hex chars)
df = pms.df(msg)             # Get Downlink Format (e.g. 17 for ADS-B) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,CRC%20or%20generate%20parity%20bit))
icao = pms.icao(msg)         # Get the aircraft's ICAO 24-bit address (hex) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,CRC%20or%20generate%20parity%20bit))
crc_ok = (pms.crc(msg) == 0) # Check CRC integrity (0 means no error) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,CRC%20or%20generate%20parity%20bit)) ([pyModeS.common module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.common.html#module-pyModeS.common#:~:text=%60pyModeS.common.%60%60crc%60%28msg%2C%20encode%3DFalse%29))

if df == 17 and crc_ok:       # If it’s a valid ADS-B message
    tc = pms.adsb.typecode(msg)           # ADS-B type code (1-31) for message subtype
    if 1 <= tc <= 4:
        callsign = pms.adsb.callsign(msg) # Decode aircraft callsign (flight ID) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=%23%20Typecode%201))
        print("Callsign:", callsign)
    elif 9 <= tc <= 18:
        alt = pms.adsb.altitude(msg)      # Decode reported altitude (feet) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms))
        print("Altitude:", alt, "ft")
    # ... (handle other type codes such as position or velocity)
``` 

In this snippet, we used `pms.df` to get the Downlink Format and `pms.icao` to extract the ICAO address from the raw message. We then checked `pms.crc`, which computes the Mode S CRC to verify the message’s integrity ([pyModeS.common module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.common.html#module-pyModeS.common#:~:text=%60pyModeS.common.%60%60crc%60%28msg%2C%20encode%3DFalse%29)). For an ADS-B message (DF=17) with no CRC errors, we used the **Type Code** (TC) to determine what kind of information the message contains, then called the appropriate decoder function (e.g., `pms.adsb.callsign` for identification messages, or `pms.adsb.altitude` for airborne position messages that contain altitude). Similar functions exist for position and velocity as described below in the API reference.

**Reading from a network feed in code:** pyModeS provides a helper class `TcpClient` (in `pyModeS.extra.tcpclient`) for streaming Mode S data from a network source. You can subclass this to handle incoming messages. For example, to connect to a Beast-format feed on localhost port 30005 and print out basic info for each valid ADS-B message:

```python
from pyModeS.extra.tcpclient import TcpClient
import pyModeS as pms

class ADSBClient(TcpClient):
    def handle_messages(self, messages):
        for msg, ts in messages:            # msg is hex string, ts is timestamp
            if len(msg) != 28: 
                continue                   # skip if not a 28-char message
            if pms.df(msg) != 17: 
                continue                   # skip non-ADS-B messages ([Welcome to pyModeS documentation! — pyModeS  documentation](https://mode-s.org/pymodes/api/#:~:text=def%20handle_messages,wrong%20data%20length%20continue))
            if pms.crc(msg) != 0: 
                continue                   # skip messages that fail CRC check ([Welcome to pyModeS documentation! — pyModeS  documentation](https://mode-s.org/pymodes/api/#:~:text=if%20df%20%21%3D%2017%3A%20,not%20ADSB%20continue))
            icao = pms.adsb.icao(msg)
            tc = pms.adsb.typecode(msg)
            print(ts, icao, tc, msg)       # print timestamp, ICAO, type code, raw message

# Start the client
client = ADSBClient(host="127.0.0.1", port=30005, rawtype="beast")
client.run()
``` 

This client connects to the given host/port and calls our `handle_messages` method with batches of messages. In the example, we filtered to only process ADS-B messages (DF17) with correct CRC, then printed out the ICAO address and type code ([Welcome to pyModeS documentation! — pyModeS  documentation](https://mode-s.org/pymodes/api/#:~:text=def%20handle_messages,wrong%20data%20length%20continue)) ([Welcome to pyModeS documentation! — pyModeS  documentation](https://mode-s.org/pymodes/api/#:~:text=if%20pms.crc%28msg%29%20%21%3D0%3A%20%20,CRC%20fail%20continue)). In practice, you could extend this to fully decode the message (e.g., get position or callsign) and perhaps store the data. The `rawtype` parameter can be `"raw"` (ASCII hex) or `"beast"` (binary) to match your data source. This approach is useful for integrating pyModeS into custom applications or data pipelines.

*(Note: If using an RTL-SDR in Python code, you would typically use the `pyrtlsdr` library to read raw samples and then a demodulator to get Mode S message hex strings. The `modeslive` tool internally handles demodulation for you. For most users, using `modeslive` or feeding data from an existing decoder (like dump1090) into pyModeS is the easiest way to get started.)*

## API Reference

Below is a comprehensive reference of the public classes and functions provided by pyModeS, organized by category. All functions assume inputs corresponding to Mode S messages in hexadecimal string format (typically 28 hex characters for long messages, 14 for short messages). Return types and units are noted. 

### Common Utility Functions (Mode S Generic)

These functions are available directly under the `pyModeS` module (importable via the alias `pms` as shown above) and handle generic Mode S message parsing and data conversion:

- **`pms.df(msg)`** – Determine the Downlink Format of a Mode S message. Returns an integer (0–31) representing the DF extracted from the first five bits of the message ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,CRC%20or%20generate%20parity%20bit)). For example, DF=17 indicates an ADS-B extended squitter message.
- **`pms.ca(msg)`** – Get the Capability (CA) field from the message (Mode S transponder capability level, bits 6–8 of the first byte). Returns an integer 0–7. *(This may be accessed via other functions; often not needed explicitly by users.)*
- **`pms.icao(msg)`** – Infer the ICAO 24-bit address of the aircraft from the message ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,CRC%20or%20generate%20parity%20bit)). Returns a 6-digit hexadecimal string (uppercase) representing the aircraft’s unique address. This is extracted from bits 9–32 of the Mode S message (the 24-bit address field).
- **`pms.crc(msg, encode=False)`** – Compute the Mode S Cyclic Redundancy Check. By default (`encode=False`), this computes the CRC on the message and returns 0 if the message is error-free (correct parity) or a non-zero integer if a parity error is detected ([pyModeS.common module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.common.html#module-pyModeS.common#:~:text=%60pyModeS.common.%60%60crc%60%28msg%2C%20encode%3DFalse%29)). If `encode=True`, the function instead returns the 24-bit parity value that should be appended to a data message ([pyModeS.common module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.common.html#module-pyModeS.common#:~:text=Detect%20if%20bit%20error%20occurs,on%2C%20the%20checksum%20is%20generated)). *Return type:* int (CRC syndrome or parity bits).
- **`pms.hex2bin(hexstr)`** – Convert a hexadecimal string to a binary string (e.g., `"A4"` -> `"10100100"`). Useful for examining specific bit fields ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,Convert%20grey%20code%20to%20integer)).
- **`pms.hex2int(hexstr)`** – Convert a hexadecimal string to an integer ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,Convert%20grey%20code%20to%20integer)).
- **`pms.bin2int(binstr)`** – Convert a binary string (e.g., `"10100100"`) to an integer ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,Convert%20grey%20code%20to%20integer)).
- **`pms.gray2int(binstr)`** – Convert a Gray code binary string to an integer (used in altitude code decoding) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,Convert%20grey%20code%20to%20integer)).

#### Mode A/C Replies (Squawk and Altitude)

- **`pms.common.altcode(msg)`** – Decode the **13-bit altitude code** from a Mode A/C reply (DF4 or DF20 message) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Decode%20altitude%20replies%20in%20DF4,DF20)). This returns the aircraft pressure altitude in feet for a message that contains an encoded Gillham code. **Parameters:** `msg` – 28-hex-digit string (DF=4/20). **Returns:** altitude (int, feet) ([pyModeS.common module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.common.html#module-pyModeS.common#:~:text=%60pyModeS.common.%60%60altcode%60%28msg%29)) ([pyModeS.common module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.common.html#module-pyModeS.common#:~:text=Returns)).
- **`pms.common.idcode(msg)`** – Decode the **Mode A identity code (Squawk)** from a DF5 or DF21 reply ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms.common.altcode%28msg%29%20%20%20,must%20be%204%20or%2020)). Returns the octal transponder code (int) assigned to the aircraft (often used by air traffic control). **Parameters:** `msg` – 28-hex message (DF=5/21). **Returns:** squawk code (int). 

*(Note: The above two functions apply to older Mode A/C replies that are sometimes carried in Mode S All-Call replies. ADS-B messages carry altitude and identity in extended squitters, decoded with different functions below.)*

### ADS-B Message Decoding (Extended Squitter DF17/18)

ADS-B messages (DF17/DF18) contain various pieces of surveillance information. pyModeS provides decoders under `pms.adsb` for each category of ADS-B message. Many of these functions correspond to specific Type Codes (TC) within the ADS-B message.

- **`pms.adsb.typecode(msg)`** – Determine the Type Code of an ADS-B message. Returns an integer 1–31 indicating the message subtype. This is often used to decide which decoder to apply (callsign vs position, etc.).

- **Identification and Category:**  
  - **`pms.adsb.callsign(msg)`** – Decode the aircraft identification (flight callsign) from an ADS-B message with TC=1–4 (BDS 0,8) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=%23%20Typecode%201)). Returns the 8-character aircraft callsign (string, usually flight number or registration) ([pyModeS.decoder.bds.bds08 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds08.html#:~:text=%60pyModeS.decoder.bds.bds08.%60%60callsign%60%28msg%29)) ([pyModeS.decoder.bds.bds08 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds08.html#:~:text=Returns)). For example, returns `"UAL1234"` for a message that encodes that callsign.  
  - **`pms.adsb.category(msg)`** – Decode the aircraft category code (TC=1–4) which indicates aircraft type or size category ([pyModeS.decoder.bds.bds08 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds08.html#:~:text=string)) ([pyModeS.decoder.bds.bds08 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds08.html#:~:text=Returns)). Returns an integer category code (0–15 for ADS-B Airborne, or 0–7 for Surface) as defined by ICAO.

- **Airborne Position (Latitude/Longitude and Altitude):**  
  ADS-B airborne position messages use an even/odd pair of messages (TC=9–18 for barometric altitude, or TC=20–22 for GNSS altitude) to derive precise latitude and longitude via the CPR (Compact Position Reporting) algorithm. pyModeS offers two ways to decode position: using a pair of messages, or using a single message with a reference position.
  - **`pms.adsb.airborne_position(msg_even, msg_odd, t_even, t_odd)`** – Compute an aircraft’s position (latitude, longitude) from a pair of even and odd ADS-B position messages ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=%23%20Typecode%205,surface_velocity%28msg)). **Parameters:** `msg_even`, `msg_odd` – the hex strings for the even and odd position messages; `t_even`, `t_odd` – the timestamps (in seconds or any time unit) when each message was received. **Returns:** a tuple `(lat, lon)` in degrees ([pyModeS.decoder.bds.bds05 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds05.html#:~:text=%60pyModeS.decoder.bds.bds05.%60%60airborne_position%60%28msg0%2C%20msg1%2C%20t0%2C%20t1%29,18)) ([pyModeS.decoder.bds.bds05 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds05.html#:~:text=Returns)). This function uses the timestamp difference to determine the correct latitude zone.  
  - **`pms.adsb.airborne_position_with_ref(msg, lat_ref, lon_ref)`** – Decode an airborne position from a single message (either even or odd) if you have a reference location near the aircraft ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,surface_position_with_ref%28msg%2C%20lat_ref%2C%20lon_ref)). **Parameters:** `msg` – one position message; `lat_ref, lon_ref` – a reference latitude/longitude (e.g., from a previous position or from a nearby receiver) within ~180 NM of the aircraft ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Note%3A%20When%20you%20have%20a,of%20the%20true%20position)) ([pyModeS.decoder.bds.bds05 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds05.html#:~:text=Decode%20airborne%20position%20with%20only,180NM%20of%20the%20true%20position)). **Returns:** `(lat, lon)` coordinates of the aircraft ([pyModeS.decoder.bds.bds05 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds05.html#:~:text=Parameters)) ([pyModeS.decoder.bds.bds05 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds05.html#:~:text=)). This is convenient for getting a quick position update when continuous tracking provides an approximate last known position.
  - **`pms.adsb.altitude(msg)`** – Decode the reported **pressure altitude** from an airborne position message ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms)). **Parameters:** ADS-B position message (TC=9–18 or 20–22). **Returns:** altitude in feet (int) ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=%60pyModeS.decoder.adsb.%60%60altitude%60%28msg%29)) ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=altitude%20in%20feet)). This accounts for the 12-bit altitude code in the message (with Q-bit for 25 ft or 100 ft resolution).

  *Usage note:* To decode an aircraft’s airborne position, you typically collect one even and one odd message (which are broadcast alternating every 0.4s). Use `airborne_position(even, odd, t_even, t_odd)` once you have both. If you only have one message or want immediate results, use a reference position with `airborne_position_with_ref`, but ensure the reference is within 180 NM for accuracy ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Note%3A%20When%20you%20have%20a,of%20the%20true%20position)) ([pyModeS.decoder.bds.bds05 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds05.html#:~:text=Decode%20airborne%20position%20with%20only,180NM%20of%20the%20true%20position)). 

- **Surface Position (Ground vehicles / taxiing aircraft):**  
  ADS-B surface position messages (TC=5–8) use a similar CPR method but with smaller zones. They include ground track angle and speed instead of heading and vertical rate.
  - **`pms.adsb.surface_position(msg_even, msg_odd, t_even, t_odd, lat_ref, lon_ref)`** – Decode a surface (on-ground) position from a pair of even/odd messages ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,surface_velocity%28msg)). Because surface position decoding requires resolving ambiguity, you must supply the receiver’s approximate lat/lon as well (this helps determine the correct position since surface positions are local) ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=,source%5D%20%2018)) ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=,for%20the%20odd%20message)). **Returns:** `(lat, lon)` in degrees ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=Returns)).
  - **`pms.adsb.surface_position_with_ref(msg, lat_ref, lon_ref)`** – Decode a surface position from a single message using a known reference location (e.g., receiver location at an airport) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,surface_position_with_ref%28msg%2C%20lat_ref%2C%20lon_ref)). **Returns:** `(lat, lon)` coordinates ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=%60pyModeS.decoder.bds.bds06.%60%60surface_position_with_ref%60%28msg%2C%20lat_ref%2C%20lon_ref%29)) ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=,28%20hexdigits)). The reference should be within ~45 NM for surface positions ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=lon_ref%29)).
  - **`pms.adsb.surface_velocity(msg)`** – Decode the ground speed and track from a surface position message (TC=5–8) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=pms,surface_velocity%28msg)). **Returns:** If successful, a tuple of four values: `(speed_kt, track_deg, vertical_rate, speed_type)` ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=Returns)) ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=,ground%20speed%2C%20%E2%80%98AS%E2%80%99%20for%20airspeed)). For surface messages, vertical rate is always 0 (since on ground), and `speed_type` will indicate whether the speed is reported as Ground Speed (`"GS"`) or Airspeed (`"AS"`) ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=Four%20or%20six%20parameters%2C%20including%3A)). If you pass `source=True` to this function (available in the low-level API), it will additionally return the data source indicators (which are generally constant for surface: true north reference for track, and no vertical rate source) ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=,hexdigits%20string)) ([pyModeS.decoder.bds.bds06 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds06.html#:~:text=,ground%20speed%2C%20%E2%80%98AS%E2%80%99%20for%20airspeed)). *(In typical use, calling this with default `source=False` is sufficient to get speed and track.)*

- **Airborne Velocity (Speed and Heading):**  
  ADS-B velocity messages (Type Code 19) provide ground speed or airspeed and heading information, plus vertical climb/descent rate. There are two subtypes: “airborne velocity over ground” (ground track and ground speed) and “airborne velocity through air” (heading and airspeed), as well as indication of barometric vs GNSS vertical rate. pyModeS will decode either type.
  - **`pms.adsb.velocity(msg)`** – General decoder for ADS-B velocity messages (TC=19) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,airborne_velocity%28msg)). Returns a tuple of four values: `(speed_kt, heading_deg, vertical_rate_fpm, speed_type)` where `speed_type` is `"GS"` (ground speed) or `"AS"` (air speed) indicating which subtype it was ([pyModeS.decoder.bds.bds09 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds09.html#:~:text=Four%20or%20six%20parameters%2C%20including%3A)). The `heading_deg` is either ground track or true heading depending on subtype, and `vertical_rate_fpm` is the climb/descent rate in feet per minute (can be negative for descent). Under the hood, this function calls either `airborne_velocity` or `surface_velocity` appropriately; since TC=19 is only for airborne, it effectively wraps `pms.adsb.airborne_velocity` described below.
  - **`pms.adsb.airborne_velocity(msg, source=False)`** – Decode an airborne velocity message explicitly (TC=19) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,airborne_velocity%28msg)). **Returns:** a tuple containing: speed (knots), angle (degrees), vertical rate (ft/min), and speed type (string) ([pyModeS.decoder.bds.bds09 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds09.html#:~:text=Four%20or%20six%20parameters%2C%20including%3A)). If `source=True`, two additional values are returned indicating the reference for angle (`"TRUE_NORTH"` or `"MAGNETIC_NORTH"`) and source of vertical rate (`"BARO"` or `"GNSS"`) ([pyModeS.decoder.bds.bds09 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds09.html#:~:text=,track%20or%20heading)). For example, an airborne velocity message might yield `(450, 270.0, 0, 'GS')` meaning 450 knots ground speed, track 270°, level flight, ground speed type. Another might yield `(300, 265.0, 1500, 'AS')` meaning 300 kt airspeed, heading ~265°, climbing at 1500 ft/min, airspeed type.
  - **`pms.adsb.speed_heading(msg)`** – (Alias for `pms.adsb.velocity`) This function will decode either surface or airborne velocity depending on the message content and is provided for convenience ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,airborne_velocity%28msg)).
  - **`pms.adsb.airborne_velocity_with_ref(msg, lat_ref, lon_ref)`** – This function is not typically needed; ADS-B velocity decoding does not require a reference position (unlike position decoding). *pyModeS does not list a separate `with_ref` for velocity; ignore if mentioned in older docs.*

- **Other ADS-B information:**  
  ADS-B version 2 messages (TC=28-31, “extended operational status”) include **Navigation Accuracy Category** and **Integrity** indicators. pyModeS provides functions to decode these bits if needed:
  - **`pms.adsb.nac_p(msg)`**, **`pms.adsb.nac_v(msg)`** – Get the Navigation Accuracy Category for Position or Velocity from the message. For example, `nac_p` (for TC=29 or 31) gives the 95% horizontal and vertical position uncertainty bounds ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=%60pyModeS.decoder.adsb.%60%60nac_p%60%28msg%29)) ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=95,bounds%2C%20Vertical%20Estimated%20Position%20Uncertainty)), and `nac_v` (for TC=19 velocity messages) gives the 95% horizontal/vertical velocity uncertainty ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=%60pyModeS.decoder.adsb.%60%60nac_v%60%28msg%29)) ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=Returns)). Return values may be integers or special strings if “unknown”.  
  - **`pms.adsb.nic_b(msg)`, `nic_a_c(msg)`, `nic_s(msg)`** – Decode **Navigation Integrity Category** supplemental bits from TC=31 messages ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=%60pyModeS.decoder.adsb.%60%60nic_a_c%60%28msg%29)) ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=NICa%20and%20NICc%20number%20,or%201)). These indicate the system’s integrity containment radius/levels (used in ADS-B version 2). They return 0 or 1 (or tuple for NIC A and C) indicating the presence of certain integrity bounds ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=Returns)) ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=%60pyModeS.decoder.adsb.%60%60nic_b%60%28msg%29)).  
  In most basic use cases, you won’t need to call these functions unless you are analyzing the quality indicators of ADS-B messages. They are included for completeness for ADS-B v2 (DO-260B) support.

### Mode S Comm-B Message Decoding (BDS Registers)

Mode S Comm-B replies (DF20/21) contain data in various registers identified by **BDS codes** (Biennial Data Selector, two numbers like 1,0 or 6,0). pyModeS can decode many of these registers, which are typically obtained via interrogations from ground radar. These are not broadcast continuously like ADS-B, but if you have Mode S Comm-B data, the following functions apply (available under `pms.commb` or `pms.bds` submodules):

**Elementary Surveillance (ELS) – Basic Comm-B (BDS 1,0, 1,7, 2,0, 3,0):**

- **`pms.commb.ovc10(msg)`** – Decode Overlay Capability from a **BDS 1,0 (Data Link Capability Report)** message ([pyModeS.decoder.bds.bds10 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds10.html#:~:text=%60pyModeS.decoder.bds.bds10.%60%60ovc10%60%28msg%29)) ([pyModeS.decoder.bds.bds10 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds10.html#:~:text=Whether%20the%20transponder%20is%20OVC,capable)). Returns an integer (0 or 1) indicating whether the transponder has “overlay capability” (OVC) for data link applications. **Parameter:** `msg` – 28-hex string for a Comm-B message. (Use only on messages known or suspected to be BDS1,0; see `infer()` below.)
- **`pms.commb.cap17(msg)`** – Decode the Common Usage GICB Capability Report from a **BDS 1,7** message ([pyModeS.decoder.bds.bds17 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds17.html#:~:text=%60pyModeS.decoder.bds.bds17.%60%60cap17%60%28msg%29)) ([pyModeS.decoder.bds.bds17 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds17.html#:~:text=list%20of%20support%20BDS%20codes)). Returns a list of supported BDS codes (list of strings like `["BDS2,0", "BDS4,0", ...]`) indicating which Comm-B registers the transponder can downlink ([pyModeS.decoder.bds.bds17 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds17.html#:~:text=msg%20,string)). Essentially, BDS1,7 contains a bit matrix of availabilities, and this function interprets it.
- **`pms.commb.cs20(msg)`** – Decode the **Aircraft Identification (Callsign)** from a **BDS 2,0** message ([pyModeS.decoder.bds.bds20 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds20.html#:~:text=%60pyModeS.decoder.bds.bds20.%60%60cs20%60%28msg%29)) ([pyModeS.decoder.bds.bds20 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds20.html#:~:text=Returns)). This is similar to ADS-B callsign, but obtained via Mode S interrogation. Returns the callsign (string up to 8 chars). (If an aircraft is not ADS-B equipped, ground radars can request its callsign via BDS2,0.)
- **(ACAS)** **`pms.commb.ra30(msg)`**, etc. – *ACAS active resolution advisory (BDS 3,0) decoding is not fully implemented in pyModeS.* The BDS3,0 “ACAS RA report” content might be partially accessible if needed (e.g., via low-level functions), but currently pyModeS mainly provides `pms.bds.bds30.is30(msg)` to detect if a message is likely BDS3,0 ([pyModeS.decoder.bds.bds30 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds30.html#:~:text=%60pyModeS.decoder.bds.bds30.%60%60is30%60%28msg%29)) ([pyModeS.decoder.bds.bds30 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds30.html#:~:text=Returns)). (Detailed ACAS RA fields would include active RA sense, etc., and may be added in future.)

**Enhanced Surveillance (EHS) – Aircraft State Parameters (BDS 4,0, 5,0, 6,0):**

These registers are typically downlinked by Mode S EHS-capable aircraft when interrogated by radar. pyModeS decoders for these include:

- **BDS 4,0 – Selected Vertical Intention:**  
  Contains autopilot/flight management system selected altitudes and barometric setting.
  - **`pms.commb.selalt40mcp(msg)`** – Selected altitude (MCP/FCU). Decodes the altitude (feet) selected in the Mode Control Panel (or Flight Control Unit) ([pyModeS.decoder.bds.bds40 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds40.html#:~:text=%60pyModeS.decoder.bds.bds40.%60%60selalt40fms%60%28msg%29)) ([pyModeS.decoder.bds.bds40 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds40.html#:~:text=altitude%20in%20feet)). This is typically the altitude set by the pilot or autopilot for level-off. *Return:* int (feet).
  - **`pms.commb.selalt40fms(msg)`** – Selected altitude (FMS). Decodes the altitude (feet) selected by the Flight Management System (often an altitude constraint) ([pyModeS.decoder.bds.bds40 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds40.html#:~:text=%60pyModeS.decoder.bds.bds40.%60%60selalt40fms%60%28msg%29)) ([pyModeS.decoder.bds.bds40 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds40.html#:~:text=altitude%20in%20feet)). *Return:* int (feet).
  - **`pms.commb.p40baro(msg)`** – Barometric pressure setting (QNH) from BDS4,0 ([pyModeS.decoder.bds.bds40 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds40.html#:~:text=bool)) ([pyModeS.decoder.bds.bds40 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds40.html#:~:text=Returns)). Returns the barometric setting in millibars (float). For example, 1013.25 mb is standard pressure.  
  *(Use `is40(msg)` to check if a message is BDS4,0 if you are uncertain) ([pyModeS.decoder.bds.bds40 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds40.html#:~:text=%60pyModeS.decoder.bds.bds40.%60%60is40%60%28msg%29)) ([pyModeS.decoder.bds.bds40 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds40.html#:~:text=True%20or%20False)).*

- **BDS 5,0 – Track and Turn Report:**  
  Contains various measurements like roll angle, track, etc.
  - **`pms.commb.roll50(msg)`** – Aircraft roll angle (degrees) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=%60pyModeS.decoder.bds.bds50.%60%60roll50%60%28msg%29)) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=angle%20in%20degrees%2C)). Returns a float, where positive means right wing down, negative means left wing down. (Range ~ –90 to +90 degrees.)
  - **`pms.commb.trk50(msg)`** – True track angle (degrees) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=%60pyModeS.decoder.bds.bds50.%60%60trk50%60%28msg%29)) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=Returns)). Returns a float 0–360 representing the aircraft’s ground track relative to true north.
  - **`pms.commb.gs50(msg)`** – Ground speed (knots) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=%60pyModeS.decoder.bds.bds50.%60%60gs50%60%28msg%29)) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=Returns)). Returns int (knots).
  - **`pms.commb.rtrk50(msg)`** – Track angle rate (deg/sec) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=%60pyModeS.decoder.bds.bds50.%60%60rtrk50%60%28msg%29)) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=Returns)). Returns float (degrees per second, turn rate).
  - **`pms.commb.tas50(msg)`** – True airspeed (knots) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=%60pyModeS.decoder.bds.bds50.%60%60tas50%60%28msg%29)) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=Returns)). Returns int (knots).  
  *(Use `is50(msg)` to test if a message is likely BDS5,0) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=%60pyModeS.decoder.bds.bds50.%60%60is50%60%28msg%29)) ([pyModeS.decoder.bds.bds50 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds50.html#:~:text=Returns)).*

- **BDS 6,0 – Heading and Speed Report:**  
  Contains indicated airspeed, magnetic heading, Mach, and vertical rates.
  - **`pms.commb.hdg60(msg)`** – Magnetic heading (degrees) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=pyModeS)) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=Returns)). Returns float (heading relative to magnetic north, 0–360).
  - **`pms.commb.ias60(msg)`** – Indicated airspeed (knots) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=float)) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=Returns)). Returns int (knots).
  - **`pms.commb.mach60(msg)`** – Mach number ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=bool)) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=Returns)). Returns float (e.g., 0.84).
  - **`pms.commb.vr60baro(msg)`** – Barometric vertical rate (ft/min) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=%60pyModeS.decoder.bds.bds60.%60%60mach60%60%28msg%29)) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=Returns)). Returns float (vertical speed based on barometric altitude change, which may be noisy). 
  - **`pms.commb.vr60ins(msg)`** – Inertial vertical rate (ft/min). (Not explicitly shown above, but analogous; if available, returns the inertial vertical speed from IRS.)  
  *(Use `is60(msg)` to check if BDS6,0) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=int)) ([pyModeS.decoder.bds.bds60 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds60.html#:~:text=Returns)).*

**Meteorological Reports (BDS 4,4 and 4,5 – Experimental):**

Some aircraft can downlink meteorological data via Mode S if interrogated (MRAR/MHR messages). pyModeS marks these decoders as experimental:

- **BDS 4,4 – Meteorological Routine Air Report (MRAR):**  
  - **`pms.commb.wind44(msg)`** – Wind data: decodes **wind speed (knots)** and **wind direction (degrees true)** ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=%60pyModeS.decoder.bds.bds44.%60%60wind44%60%28msg%29)) ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=speed%20)). Returns a tuple `(speed_int, direction_float)`. 
  - **`pms.commb.temp44(msg)`** – Static air temperature (°C) ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=%60pyModeS.decoder.bds.bds44.%60%60temp44%60%28msg%29)) ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=temperature%20and%20alternative%20temperature%20in,Celsius%20degree)). *Note:* Due to an ICAO document inconsistency, this returns two values (possibly representing two interpretations); for simplicity, use the first value which is the temperature in Celsius ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=msg%20,string)) ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=Return%20type)).
  - **`pms.commb.p44(msg)`** – Static pressure (hPa) ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=%60pyModeS.decoder.bds.bds44.%60%60p44%60%28msg%29)) ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=static%20pressure%20in%20hPa)). Returns int (hectopascals).
  - **`pms.commb.hum44(msg)`** – Humidity (%) ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=%60pyModeS.decoder.bds.bds44.%60%60hum44%60%28msg%29)) ([pyModeS.decoder.bds.bds44 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds44.html#:~:text=Returns)). Returns float (0-100%).  
  *(Use `pms.bds.infer(msg, mrar=True)` to help identify a MRAR message, since they are less common).*

- **BDS 4,5 – Meteorological Hazard Report (MHR):**  
  - **`pms.commb.turb45(msg)`** – Turbulence level (0=None, 1=Light, 2=Moderate, 3=Severe) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=%60pyModeS.decoder.bds.bds45.%60%60turb45%60%28msg%29)) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=Returns)).
  - **`pms.commb.ws45(msg)`** – Wind shear level (0–3) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=%60pyModeS.decoder.bds.bds45.%60%60ws45%60%28msg%29)) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=Returns)).
  - **`pms.commb.wv45(msg)`** – Wake vortex hazard level (0–3) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=%60pyModeS.decoder.bds.bds45.%60%60wv45%60%28msg%29)) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=Returns)).
  - **`pms.commb.mb45(msg)`** – Microburst level (0–3) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=%60pyModeS.decoder.bds.bds45.%60%60mb45%60%28msg%29)) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=Returns)).
  - **`pms.commb.ic45(msg)`** – Icing level (0–3) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=%60pyModeS.decoder.bds.bds45.%60%60ic45%60%28msg%29)) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=Returns)).
  - **`pms.commb.temp45(msg)`** – Static air temperature (°C) for MHR. (Similar to temp44; returns float).
  - **`pms.commb.p45(msg)`** – Static pressure (hPa) for MHR ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=%60pyModeS.decoder.bds.bds45.%60%60p45%60%28msg%29)) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=Returns)).
  - **`pms.commb.rh45(msg)`** – Radio height (ft) – the height above the terrain (radio altitude) if available. Returns int (feet).  
  *(Use `is45(msg)` to check for BDS4,5) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=%60pyModeS.decoder.bds.bds45.%60%60is45%60%28msg%29)) ([pyModeS.decoder.bds.bds45 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds45.html#:~:text=Returns)).* 

*Note:* MRAR/MHR messages are rare and only downlinked when specifically interrogated. To identify them, call `pms.bds.infer(msg, mrar=True)` which will include BDS4,4 and 4,5 in its guessing (by default, `infer` focuses on more common registers) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Meteorological%20reports%20)) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,Humidity)).

### BDS Code Inference Utilities

If you have a generic Mode S Comm-B message and need to determine what BDS code it contains, pyModeS provides helper functions:

- **`pms.bds.infer(msg, mrar=False)`** – Guess the most likely BDS code(s) for a given Comm-B message ([pyModeS.decoder.bds package — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.html#module-pyModeS.decoder.bds#:~:text=%60pyModeS.decoder.bds.%60%60infer%60%28msg%2C%20mrar%3DFalse%29)) ([pyModeS.decoder.bds package — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.html#module-pyModeS.decoder.bds#:~:text=Returns)). This examines the content (parity bits and known patterns) to suggest which BDS register the message corresponds to. **Parameters:** `msg` – 28-hex string; `mrar` – if `True`, include the possibility of BDS4,4 or 4,5 (meteorological) in the inference ([pyModeS.decoder.bds package — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.html#module-pyModeS.decoder.bds#:~:text=,hexdigits%20string)). **Returns:** a string like `"BDS5,0"` or a list of possible codes, or `None` if unknown ([pyModeS.decoder.bds package — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.html#module-pyModeS.decoder.bds#:~:text=Returns)). For example, it might return `"BDS2,0"` if the message structure matches an Aircraft ID report.
- **`pms.bds.is50or60(msg, spd_ref, trk_ref, alt_ref)`** – Special utility to distinguish between BDS 5,0 and 6,0 for a given message ([pyModeS.decoder.bds package — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.html#module-pyModeS.decoder.bds#:~:text=%60pyModeS.decoder.bds.%60%60is50or60%60%28msg%2C%20spd_ref%2C%20trk_ref%2C%20alt_ref%29,21)) ([pyModeS.decoder.bds package — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.html#module-pyModeS.decoder.bds#:~:text=,B%20altitude%29%2C%20ft)). These two EHS messages have similar structure, so this function uses reference data from ADS-B (speed, track, altitude) to guess whether the message is a Track&Turn (5,0) or Heading&Speed (6,0) report ([pyModeS.decoder.bds package — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.html#module-pyModeS.decoder.bds#:~:text=Parameters)) ([pyModeS.decoder.bds package — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.html#module-pyModeS.decoder.bds#:~:text=,B%20altitude%29%2C%20ft)). It returns `"BDS5,0"`, `"BDS6,0"`, or `None`. Typically, you would supply the aircraft’s known ground speed, track, and altitude from ADS-B to help decide (since a BDS6,0 will usually correspond to the same values as ADS-B if available, whereas BDS5,0 contains different info like roll). In practice, `pms.bds.infer` may call this internally.

Additionally, for each individual BDS code, there are boolean functions to test if a message is likely that code: e.g., `pms.bds.bds10.is10(msg)`, `pms.bds.bds17.is17(msg)`, ..., `pms.bds.bds60.is60(msg)` ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,is60%28msg)). These return True/False based on certain bits in the message. In most cases, using `infer()` is more convenient, but these exist for completeness or low-level checks.

### Classes and Modules

- **`pyModeS.extra.tcpclient.TcpClient`** – A base class for building a TCP client to receive Mode S data streams ([Welcome to pyModeS documentation! — pyModeS  documentation](https://mode-s.org/pymodes/api/#:~:text=Customize%20the%20streaming%20module%C2%B6)). As shown in the usage example above, you subclass this and override the `handle_messages(self, messages)` method to define what to do with incoming data. The `messages` passed to that method is a list of `(msg, timestamp)` tuples. You construct the client with the server address, port, and raw data type (`'raw'` or `'beast'`), then call `.run()` to start listening ([Welcome to pyModeS documentation! — pyModeS  documentation](https://mode-s.org/pymodes/api/#:~:text=,ts%2C%20icao%2C%20tc%2C%20msg)). This class internally uses ZeroMQ (`pyzmq`) to manage the socket connection and will handle reconnection etc. Use this if you want to integrate pyModeS decoding in a long-running application that pulls data from a network feed.

- **Module structure:** Internally, pyModeS is organized into modules (as seen in the import paths above): 
  - `pyModeS.common` for generic functions (df, CRC, conversions, altcode, idcode, etc.). 
  - `pyModeS.decoder.adsb` for ADS-B decoders, 
  - `pyModeS.decoder.bds` (with submodules bds05, bds06, etc.) for Comm-B decoders, 
  - `pyModeS.decoder.commb` as a convenience aggregator for all Comm-B decoders, 
  - `pyModeS.extra` for extra utilities (like `tcpclient`). Most users will not need to import these submodules directly, since the high-level `pms.` interface exposes the needed functions, but understanding the structure can help navigate the documentation. For example, `pms.adsb.callsign` is actually implemented in `pyModeS.decoder.bds.bds08.callsign`, and `pms.commb.roll50` is implemented in `pyModeS.decoder.bds.bds50.roll50`, etc., as noted in the documentation ([pyModeS.decoder.adsb module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.adsb.html#:~:text=The%20ADS,functions%20from%20the%20following%20modules)).

## Performance and Limitations

**Performance:** pyModeS is designed to efficiently decode messages in real time. The core logic is implemented in Python with NumPy, but a C/Cython extension is available to accelerate critical decoding steps. Using the compiled version (via conda or building the extension) can significantly improve throughput, especially if you are processing tens of thousands of messages per second ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=If%20you%20want%20to%20make,as%20follows)). The Python-only version is typically sufficient for moderate traffic or a single receiver feed. If you encounter performance bottlenecks, ensure you have the C extension installed (check if `pms` is using `pyModeS_c` internally, which indicates the compiled module). Also, pyModeS focuses on single-message decoding; it does not yet vectorize or process batches of messages in one call (though you could easily loop over messages or use Python multiprocessing for parallelism). In the future, the library may offer more direct support for bytes input or bulk decoding to further speed up large-scale processing ([Performance improvement and numpy vectorization · Issue #61 · junzis/pyModeS · GitHub](https://github.com/junzis/pyModeS/issues/61#:~:text=When%20I%20receive%20ADS,saving%20string%20version%20of%20messages)) ([Performance improvement and numpy vectorization · Issue #61 · junzis/pyModeS · GitHub](https://github.com/junzis/pyModeS/issues/61#:~:text=junzis%20%20%20commented%20,66)).

**Limitations:** Some Mode S message types are not fully supported or are awaiting implementation:
- **ACAS RA (DF0/16, BDS 3,0):** Decoding of Airborne Collision Avoidance System resolution advisories is not provided (other than identifying the message) ([pyModeS.decoder.acas module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.acas.html#module-pyModeS.decoder.acas#:~:text=pyModeS)).
- **All-Call replies (DF11):** Not decoded by pyModeS at this time ([pyModeS.decoder.allcall module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.allcall.html#module-pyModeS.decoder.allcall#:~:text=pyModeS)). DF11 all-call replies just contain the ICAO and possibly capability, which can be extracted by `pms.icao()` and `pms.df()`, but no dedicated function.
- **Surveillance (DF4/5 beyond altcode/idcode):** The library covers extracting altitude and squawk from DF4/5 via `altcode` and `idcode`, but a full parser for the entire Comm-B frame of surveillance replies is not needed (these DFs carry Mode A/C info which is already handled) ([pyModeS.decoder.surv module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.surv.html#module-pyModeS.decoder.surv#:~:text=pyModeS)).
- **Uplink messages:** pyModeS primarily decodes downlink (aircraft-to-ground) messages. It has minimal support for Mode S uplink formats – functions like `pms.uplink.uf(msg)` and `pms.uplink.uplink_icao(msg)` can decode the Uplink Format and ICAO in interrogations ([pyModeS.decoder.uplink module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.uplink.html#module-pyModeS.decoder.uplink#:~:text=pyModeS)) ([pyModeS.decoder.uplink module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.uplink.html#module-pyModeS.decoder.uplink#:~:text=%60pyModeS.decoder.uplink.%60%60uplink_icao%60%28msg%29)) – but generally, Mode S interrogations (ground-to-air) are not commonly accessed by ADS-B receivers and thus are rarely needed.

**Dependencies:** As noted, pyModeS depends on:
- **NumPy** for binary arithmetic and possibly for any array-based operations ([pyModeS/pyproject.toml at master · junzis/pyModeS · GitHub](https://github.com/junzis/pyModeS/blob/master/pyproject.toml#:~:text=dependencies%20%3D%20%5B)).
- **pyzmq (ZeroMQ)** for the `TcpClient` networking features ([pyModeS/pyproject.toml at master · junzis/pyModeS · GitHub](https://github.com/junzis/pyModeS/blob/master/pyproject.toml#:~:text=dependencies%20%3D%20%5B)). Even if you don’t use `TcpClient` directly, this is installed as a dependency. (The `modeslive` utility uses ZMQ sockets under the hood to interface with data sources.)
- **pyrtlsdr** (optional) if you intend to use an SDR directly. Not required if you feed data from an external decoder or file ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Dependencies%20,automatically%20during%20previous%20installations%20processes)).

pyModeS is open source (GPLv3 licensed) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Readme)) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=Releases%2016)). It has been tested with many real-world ADS-B data sets, but as with any decoding library, edge cases may exist. Ensure to validate critical applications (for example, message CRC is a strong indicator of validity but unusual propagation conditions or overlapping signals could occasionally pass bad data). The library will not decode messages that fail CRC (unless you explicitly ignore CRC), so you can generally trust that the outputs correspond to valid messages.

In summary, pyModeS provides a comprehensive toolkit to go from raw Mode S/ADS-B hex strings to meaningful aviation data. With correct installation and usage as outlined above, it enables applications in aircraft tracking, surveillance data analysis, and research on Mode S communication ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=If%20you%20find%20this%20project,considering%20cite%20this%20tool%20as)). Use the high-level functions for convenience, and refer to this documentation for details on specific decoders and their outputs. Happy tracking!

**Sources:** Official pyModeS documentation and README ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=The%20Python%20ADS)) ([GitHub - junzis/pyModeS: Python decoder for Mode S and ADS-B signals](https://github.com/junzis/pyModeS#:~:text=,pyModeS)), pyModeS API reference ([pyModeS.decoder.bds.bds05 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds05.html#:~:text=Parameters)) ([pyModeS.decoder.bds.bds09 module — pyModeS  documentation](https://mode-s.org/pymodes/api/pyModeS.decoder.bds.bds09.html#:~:text=Four%20or%20six%20parameters%2C%20including%3A)), and the Mode S specification.